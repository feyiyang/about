---
layout: "../../layouts/BlogPost.astro"
title: "大话数据解构"
titlePre: [笔记]
description: "数据结构是相互之间存在一种或多种特定关系的数据元素的集合 "
pubDate: "2022/09/22"
heroImage: ""
draft: true
tag: 
   - 笔记
   - 前端
---
# 绪论
数据结构是相互之间存在一种或多种特定关系的数据元素的集合  
## 1.3 起源
现实中，我们更多的不是解决数值计算的问题，而是需要一些更科学有效的手段(比如表、树和图)的帮助，才能更好的处理问题。所以数据结构是一门研究非数值计算的程序设计问题中的操作对象，以及它们之间的关系和操作等先关问题的科学。  程序设计=数据结构+算法  
## 1.4基本概念和术语
数据：是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。  
这里说的数据其实是符号 · 可以输入到计算机中； · 能被计算机程序处理  
数据元素：是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理。也被称为记录。 比如人类中人是数据元素。  
数据项： 一个数据元素可以有若干个数据项组成。 比如人可以有眼、耳、鼻、嘴这些数据项，也可以有姓名、性别、地址、电话等数据项。这里数据项是数据的最小单位。  
数据对象：是性质相同的数据元素的集合，是数据的子集。    
## 1.5逻辑于物理结构
按视点不同，我们把数据结构分为逻辑结构和物理结构。  
逻辑结构：是指数据对象中数据元素之间的相互关系。我们今后最需要关注的问题。逻辑结构分为以下四种：  
1. 集合结构
   集合机构中的数据元素除了同属于一个集合外，它们之间没有其他关系。类似于数学中的集合。  
2. 线性结构
   线性结构中的数据元素之间是一对一的关系。  
3. 树形结构
   树形结构中的数据元素之间存在一种一对多的层次关系。
4. 图形结构
   图形结构的数据元素是多对多的关系。  
物理结构：是指数据的逻辑结构在计算机中的存储形式。 存储器主要针对内存而言的，像硬盘、软盘、光盘等外部存储器的数据组织通常用文件结构来描述。 如何存储数据元素之间的逻辑关系，是实现物理结构的重点和难点。  
数据元素的存储结构形式有两种：顺序存储和链式存储。  
1. 顺序存储结构
   是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的。  
2. 链式存储结构
   是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。数据元素的存储关系并不能反映其逻辑关系，因此需要一个指针存放数据元素的地址，这样通过地址就可以找到相关联数据元素的位置。  
逻辑结构是面向问题的，而物理结构是面向计算机的，其基本目标就是将数据及其逻辑关系存储到计算机的内存中。  
## 1.6抽象数据类型  
数据类型：是指一组性质相同的值的集合及定义在此集合上的一些操作的总称。  
抽象数据类型：是指一个数学模型及定义在该模型上的一组操作。抽象数据类型的定义仅取决于它的一组逻辑特性，而与其在计算机内部如何表示和实现无关。  
> 抽象数据类型的标准格式：
> ADT
>   抽象数据类型名称
> Data
>   数据元素之间逻辑关系的定义
> Operation
>   操作1
>     初始条件
>     操作结果描述
>   操作2
>     ......
>   操作n
>     ......
> endADT
-------
# 算法
算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。  
## 2.5算法的特性
算法具有五个基本特性：输入、输出、有穷性、确定性和可行性。  
有穷性：指算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每一个步骤在可接受的时间内完成。  
确定性：算法的每一步骤都具有确定的含义，不会出现二义性。  
可行性：算法的每一步都必须是可行的，也就是说，每一步都能够通过执行有限次数完成。可行性意味着算法可以转换为程序上机运行，并得到正确的结果。  
## 2.6算法设计的要求
正确性：算法至少应该具有输入、输出和加工处理无歧义性、能正确反映问题的需求、能够得到问题的正确答案。  
正确的四个层次。1. 算法程序没有语法错误。2. 算法程序对于合法的输入数据能够产生满足要求的输出结果。 3. 算法程序对于非法的输入数据能够得到满足规格说明的结果。  
可读性：算法设计的另一目的是为了便于阅读、理解和交流。  
健壮性：当输入数据不合法时，算法也能做出相关处理，而不是产生异常或莫名其妙的结果。  
时间效率高和存储量低  
## 2.7算法效率的度量方法
事后统计方法：这种方法主要是通过设计好的测试程序和数据，利用计算机计时器对不同算法编制的程序的运行时间进行比较，从而确定算法效率的高低。  
这种方法有很大缺陷。 ·依据算法事先编号程序 ·比较依赖计算硬件和软件等环境因素掩盖算法本身优劣。 ·测试数据设计困难。  
事前分析估算方法：在计算机程序编制前，依据统计方法对算法进行估算。   
进分析发现高级程序消耗时间取决：1.算法采用的策略、方法。2.编译产生的代码质量。3.问题的输入规模。4.机器执行指令的速度。 
测定运行时间最可靠方法是计算对运行时间有消耗的基本操作的执行次数。我们在分析一个算法的运行时间时，重要的是把基本操作的数量与输入规模关联起来，即基本操作的数量必须表示成输入规模的函数。  
## 2.8函数的渐进增长
输入规模n在没有限制的情况下，只要超过一个数值N，这个函数就总是大于另一个函数，我们称函数是渐进增长的。  
随着n增大可以忽略加法常数。 判断一个算法的效率时，函数中的常数和其它次要项常常可以忽略，而更应该关注主项(最高阶项)的阶数。 
## 2.9算法时间复杂度
算法的时间度量$T(n)=O(f(n))$. 表示随问题规模n的增大，算法执行时间的增长率和$f(n)$的增长率相同，称作算法的渐进时间复杂度，简称为时间复杂度。 这样用大写的O()来体现算法时间复杂度的记法称为大O记法。  
推导大O阶
1. 用常数1取代运行时间中的所有加法常数。
2. 在修改后的运行次数函数中，只保留最高阶项。
3. 如果最高阶项存在且不是1，则去除与这个项相乘的常数。 
## 2.10常见时间复杂度  

执行次数 | 函数阶 | 非正式术语 
:-|:-|:-
$ 12 $ | $ O(1) $ | 常数阶☕
$ 2n+3 $ | $ O(n) $ | 线性阶☕
$ 3n^2+2n+1 $ | $ O(n^2) $ | 平方阶☕
$ 5log_2n+20 $ | $ O(logn) $ | 对数阶☕
$ 2n+3nlog_2n+19 $ | $ O(nlogn) $ | nlogn阶☕
$ 6n^3+2n^2+3n+4 $ | $ O(n^3) $ | 立方阶🧊
$ 2^n $ | $ O(2^n) $ | 指数阶🧊

从小到大:   
$$
O(1)<O(logn)<O(nlogn)<O(n^2)<O(n^3)<O(2^n)<O(n!)<O(n^n) 
$$

n^2^

























